grammar MiniJava;
@header{
	import java.util.*;
}
prog      :   (class_list += class_decl)+;

//define class_decl
class_decl
locals[
	String name    
] : 
     // include class_head_name
    class_head_name 
    '{'
	  ( ('public'|'protected'|'private')? 
	  	('static' var_list  += var_decl[true,MiniJavaParser.Scope.MEMBER])
	  	|
	  	(var_list  += var_decl[false,MiniJavaParser.Scope.MEMBER])
	  	SEMICOLON
	  )*
	   (func_list += method_decl)*
	'}'
    ;

//define class_head_name and the error detection
class_head_name:
	'class' class_name = ID ( EXTENDS parent_name = ID ) ?
	{
		//notified if the class is exited
		Class_declContext parent =(Class_declContext) ($ctx.getParent());
		parent.name = $class_name.text;
		
		ProgContext prog =(ProgContext) (parent.getParent());
		
		if (MiniJavaParser.isClassExists(prog,parent.name))
			System.out.println("class name: " + parent.name + " is refined " + "at line " 
					+ $class_name.line + ":" + $class_name.pos
				);
		else
			System.out.println("add new class name:" + parent.name + " to class name list");	
	}
	; 

//define var declaration and the error detection code
var_decl[boolean static_flag,MiniJavaParser.Scope var_scope]
locals
[
	String type;
	String name;
	boolean is_static = false; 
	MiniJavaParser.Scope scope 
]
	:var_type ID 
	{
		String var_name = $ID.text;
		$ctx.type = $var_type.text;
		$ctx.name = $ID.text;
		$ctx.scope = $var_scope;
		$ctx.is_static = $static_flag;
		
		ParserRuleContext parent = $ctx.getParent();
                                if (parent instanceof Class_declContext) {  //Var belongs to a class
			Class_declContext c =(Class_declContext)(parent);
			Var_declContext var = MiniJavaParser.findVar(c,var_name);
			
			if (var != null && var.is_static == $static_flag){
				System.out.println("var " + $ID.text + " is refined " + "at line " 
					+ $ID.line + ":" + $ID.pos
					);
			}
			else {
				System.out.println("add new member var: " + $ctx.name + 
					" in class " + c.name + " successful"
				);
			}
		}