grammar MiniJava;
@header{
	import java.util.*;
}
prog      :   (class_list += class_decl)+;

//define class_decl
class_decl
locals[
	String name    
] : 
     // include class_head_name
    class_head_name 
    '{'
	  ( ('public'|'protected'|'private')? 
	  	('static' var_list  += var_decl[true,MiniJavaParser.Scope.MEMBER])
	  	|
	  	(var_list  += var_decl[false,MiniJavaParser.Scope.MEMBER])
	  	SEMICOLON
	  )*
	   (func_list += method_decl)*
	'}'
    ;

//define class_head_name and the error detection
class_head_name:
	'class' class_name = ID ( EXTENDS parent_name = ID ) ?
	{
		//notified if the class is exited
		Class_declContext parent =(Class_declContext) ($ctx.getParent());
		parent.name = $class_name.text;
		
		ProgContext prog =(ProgContext) (parent.getParent());
		
		if (MiniJavaParser.isClassExists(prog,parent.name))
			System.out.println("class name: " + parent.name + " is refined " + "at line " 
					+ $class_name.line + ":" + $class_name.pos
				);
		else
			System.out.println("add new class name:" + parent.name + " to class name list");	
	}
	; 

//define var declaration and the error detection code
var_decl[boolean static_flag,MiniJavaParser.Scope var_scope]
locals
[
	String type;
	String name;
	boolean is_static = false; 
	MiniJavaParser.Scope scope 
]
	:var_type ID 
	{
		String var_name = $ID.text;
		$ctx.type = $var_type.text;
		$ctx.name = $ID.text;
		$ctx.scope = $var_scope;
		$ctx.is_static = $static_flag;
		
		ParserRuleContext parent = $ctx.getParent();
                                if (parent instanceof Class_declContext) {  //Var belongs to a class
			Class_declContext c =(Class_declContext)(parent);
			Var_declContext var = MiniJavaParser.findVar(c,var_name);
			
			if (var != null && var.is_static == $static_flag){
				System.out.println("var " + $ID.text + " is refined " + "at line " 
					+ $ID.line + ":" + $ID.pos
					);
			}
			else {
				System.out.println("add new member var: " + $ctx.name + 
					" in class " + c.name + " successful"
				);
			}
		}

		else if (parent instanceof Para_declContext)
		{ 
			//If the var is a function parameter,find the parent node
			while (!(parent instanceof Method_declContext) ){
				parent = parent.getParent();
			}
						
			Method_declContext c =(Method_declContext)parent;
			
			if (MiniJavaParser.isParaExists(c,var_name))
			{
				System.out.println("para " + $ID.text+" in function" + c.name + " is refined " + "at line " 
					+ $ID.line + ":" + $ID.pos
					);
			}
			else {
				System.out.println("add new par: " + $ctx.name +" in function " + c.name + " successful");
			}	
		}

		else if (parent instanceof Method_declContext){  
			//if the var is a local variable in a funciton
			Method_declContext c = (Method_declContext)parent;
			
			if (MiniJavaParser.isVarExists(c,var_name))
			{
				System.out.println("var " + $ID.text +" in function" + c.name + " is refined " + "at line " 
					+ $ID.line + ":" + $ID.pos
				);
			}
			else if (MiniJavaParser.isParaExists(c,var_name))
			{
				System.out.println("var " + $ID.text +" in function " + c.name 
				 + " has same name with some para " + "at line "+ $ID.line + ":" + $ID.pos);
			}
			else 
			{
				System.out.println("add new var: " + $ctx.name 
					+" in function " + c.name + " successful"
				);
			} 
		}
	}
	;

method_decl
locals[
	String name;     //fuciton name
	String type;  //return type
	boolean is_static 
]
:
	//define method
	('public'|'protected'|'private')? (b='static')? 
	func_head_name LEFT_PARA (para_list += para_decl (',' para_list += para_decl)*)? RIGHT_PARA
	'{'
	 (
	 	('static' var_list += var_decl[true,MiniJavaParser.Scope.FUNC] SEMICOLON)
	 	|
	 	(var_list += var_decl[false,MiniJavaParser.Scope.FUNC] SEMICOLON) 
	 )*
	 (stat_list += stat)*
	'}'

	{
		$ctx.is_static = ($b.text!=null);
		//Check if the function can be overloaded
		Class_declContext parent =(Class_declContext) ($ctx.getParent());
		if (MiniJavaParser.isFuncExists(parent,$ctx))
		{
			System.out.println("overload function:" + $ctx.name + " in class "+ parent.name + "failed"
			+ " at line " + $LEFT_PARA.line + ":" + $LEFT_PARA.pos	
			);
		}
		else {
			System.out.println("add function:" + $ctx.name + " to class " + parent.name + " success");		
		}
	} 
	;
	
func_head_name:
	func_type ID
	{
		//Record function name and return type name
		Method_declContext c =(Method_declContext)($ctx.getParent()); 
		c.name = $ID.text;
		c.type = $func_type.text;
	}
	;	

para_decl:
	var=var_decl[false,MiniJavaParser.Scope.FUNC]
	#ParaDecl
	;

func_type:
	'void'|var_type
	;


var_type:
	array_type
	|basic_type
	;


basic_type:
	'int'
	|'boolean'
	|ID
	;
	
array_type:
	basic_type ('['']')+ 
	;	

class_body_start:LEFT_BRACE
	;
	
class_body_end:RIGHT_BRACE
	;

stat:
	'{' (stat)* '}'
	|'return' (expr)? ';'
	|	'if' '(' expr ')' stat 'else' stat
	|	'while' '(' expr ')' stat
	|	'System.out.println' '(' expr ')' ';'
	|	ID (array_index)? ASSIGN_OP expr ';'
	{
		//Check the stat, the ID on the left must exist, and the name of the expression on the right is the same
	}
	;		


expr_list:
	expr(',' expr)*
	;

expr returns [String type]:      //type记录表达式的类型名
	'(' a=expr ')'
	{
		$type = $a.type;
	}
	|	a = expr  op='[' b= expr ']'
	{
		MiniJavaParser.checkArrayType($a.type,$op);
		MiniJavaParser.checkType($b.type,$op,"int");
		if (MiniJavaParser.isArrayType($a.type)){
			int L =$a.type.length();
			$type = $a.type.substring(0,L-2);
		}
	}